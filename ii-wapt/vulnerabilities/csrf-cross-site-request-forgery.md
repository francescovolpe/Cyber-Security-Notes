# CSRF

<details>

<summary>Impact</summary>

* The attacker causes the victim user to carry out an action unintentionally
  * Change password, email, make a funds transfer

<!---->

* If the victim is a privileged user the attacker might be able to take full control of all the application's

</details>

## Conditions

* A relevant action
  * Example: change password
* Cookie-based session handling
* No unpredictable request parameters:
  * If you need to know the value of the existing password -> no vulnerable

## Examples

1. with POST

```
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

2. with GET

```
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```

## Defences

1. CSRF tokens
2. SameSite cookies
3. Referer-based validation

### CSRF tokens bypass

* A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client

```
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

#### Common flaws in CSRF token validation

* Validation of CSRF token depends on request method
  * Some apps correctly validate the token for POST requests but skip validation for GET requests.
    * Switch from POST to the GET method to bypass
* Validation of CSRF token depends on token being present
  * Some apps validate the token correctly when present but skip validation if it's omitted.
    * Remove the entire parameter containing the token
* CSRF token is not tied to the user session
  * Some apps don't validate if the token belongs to the same session as the requesting user.
    * Log in to the application with your account, obtain a valid token, and then feed that token to the victim user in their CSRF attack
* CSRF token is tied to a non-session cookie
  * ### TO DO
* CSRF token is simply duplicated in a cookie
  * ### TO DO

### SameSite cookies bypass

It determines when a website's cookies are included in requests originating from other websites

## TO DO

### Referer-based validation bypass

Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain

* Validation of Referer depends on header being present
  * Some apps validate the Referer header if present, but skip if omitted
  * `<meta name="referrer" content="never">`
* Validation of Referer can be circumvented
  * `http://vulnerable-website.com.attacker-website.com/csrf-attack`
  * `http://attacker-website.com/csrf-attack?vulnerable-website.com`
  * `http://attacker-website.com/vulnerable-website.com`
  * Note 1: add Referrer-Policy: unsafe-url
    * One way to set it in html: `<meta name="referrer" content="unsafe-url" />`
  * Note 2: Firefox 87 new default Referrer Policy ‘strict-origin-when-cross-origin’ trimming user sensitive information like path and query string to protect privacy. (https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/)
  * Note 3: Instead of use http://attacker-website.com/vulnerable-website.com that looks strange you can use http://attacker-website.com/ and add `<script>history.pushState('', '', '/attacker-website.com')</script>`

More info about setting Referer-Policy: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy
